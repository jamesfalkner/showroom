:imagesdir: ../assets/images

= Module 2: Design the Internal Developer Portal

include::style.adoc[]

== Overview

{product_name_rhdh} is based on the https://backstage.io/[Backstage] framework for building internal developer portals. This project was donated to the https://www.cncf.io/projects/backstage/[CNCF] by Spotify in 2020. Platform engineers can use {product_name_rhdh} to build internal developer portals. Doing so involves integrating with various data sources, catalog existing software components, infrastructure, and resources, configuring single sign-on, and more.

In this module you'll learn how to architect, install, and bootstrap an instance of {product_name_rhdh} to create a minimum viable internal developer portal for a select group of developers within your organization.

The initial use cases for your developer portal are:

* Self-service discovery of software components and dependencies.
* Visibility into CI/CD pipelines.
* Hosting documentation.
* Scaffolding projects that adhere to organizational best practices.

== Module Objectives

Satisfying the previously defined use cases involves configuring {product_name_rhdh} to integrate with your existing platforms, tools, and infrastructure. For example, if your organization uses OpenShift Pipelines for continuous integration, you'll need to configure the {product_name_rhdh} instance with the appropriate integration to fetch and display data from the an OpenShift cluster used to perform https://tekton.dev/docs/pipelines/pipelineruns/[Pipeline Runs].

It could be said that the value of an internal developer portal is proportional to the thought and energy invested into it by the platform engineer(s), and developers using it.

In this module you'll:

* Identify the platform requirements and dependencies, such as single sign-on (SSO), source code management (SCM), RBAC, resources, existing assets
* Integrate {product_name_rhdh} with the dependant services, such as GitLab and Keycloak
* Learn about https://backstage.io/docs/features/software-catalog/[Backstage Entities], e.g Components, APIs, and Docs
* Ready for developer onboarding

== Workshop Environment

Your workshop environment has been preconfigured with the following software and platform components:

* Red Hat Build of Keycloak
* OpenShift GitOps
* OpenShift Pipelines
* GitLab

For the purposes of this workshop, we'll assume that your organization has standardized on these tools, and it's your objective as the platform engineer to integrate them with {product_name_rhdh}.

For convenience, {product_name_rhdh} has been predeployed via OpenShift GitOps using the official https://docs.redhat.com/en/documentation/red_hat_developer_hub/1.3/html/installing_red_hat_developer_hub_on_openshift_container_platform/assembly-install-rhdh-ocp-helm[{product_name_rhdh} Helm Chart].

Helpful links:

* OpenShift GitOps 

TODO: Add note about the existing Argo CD application and link to the configuration repository in GitLab. Provide an overview of 

.Click to view the lab environment details
[%collapsible]
====
include::env.adoc[]
====

== Introductions to Concepts

{product_name_rhdh}, and internal developer portals in general, can be thought of as a modular systems where you aggregate and display data related to the software within an organization.

The core features of {product_name_rhdh} are the:

* Software Catalog
* Software Templates
* TechDocs
* Kubernetes Integration

=== Software Templates

Software Templates have been referred to as "Golden Paths" in the past. These templates are designed and curated by platform engineers to provide a starting point for new software components that adhere to best practices within an organization. Templates can also be used to patch and update existing source code repositories.

=== Software Catalog

The Software Catalog is a centralised asset tracker for all of the software in your organization. It stores and tracks *Entities*:

* Components: Units of software, e.g microservices, websites, libraries.
* Resources: Databases, S3 buckets, brokers.
* APIs: Represent interfaces such as REST, gRPC, and GraphQL APIs.
* Systems: Collections of Components that make up an application or platform.
* Domains: A higher-level grouping of Systems and Entities.
* User: Individual users that are part of your organization.  
* Group: Groups of Users.

Users and Groups can be specified as owners of other Entities. If this seems abstract, don't worry, you'll see it in definitive terms shortly. 

=== Plugins

Backstage - and by extension {product_name_rhdh} - supports the concept of plugins. Utilizing plugins is a critical part of enabling the desired functionality for your IDP.

Currently, adding running an instance and adding plugins to upstream Backsatge requires a platfrom engineer to:

. Create a Backstage project using Node.js and npm.
. Install the plugin(s) from npm.
. Edit the Backstage React and Node.js source code to load the plugin.
. Build a container image and deploy it.

The ability to load plugins dynamically is a value added feature included in {product_name_rhdh} that's currently unavailable in upstream Backstage - you can read more about it in the https://docs.redhat.com/en/documentation/red_hat_developer_hub/1.3/html/introduction_to_plugins/con-rhdh-plugins#con-rhdh-plugins[{product_name_rhdh} documentation]. The dynamic plugin support in {product_name_rhdh} means that new plugins can be installed without the need to edit code and rebuild the {product_name_rhdh} container image.

You'll see dynamic plugins in action shortly.

=== Understanding the {product_name_rhdh} Configuration

Upstream Backstage uses an https://backstage.io/docs/conf/[app-config.yaml] file to define configuration values. {product_name_rhdh} is no different.

A simple Backstage configuration file looks similar to the following example:

```yaml
# Define authentication configuration (this example is for testing only!)
auth:
  providers:
    guest:
      dangerouslyAllowOutsideDevelopment: true

# Static configuration for the Software Catalog. Can be used to import
# entities on startup, and restrict the entity types that can be imported.
catalog:
  rules:
    - allow: [Component, System, API, Resource, Location, Template]
  locations:
    - type: file
      target: https://github.com/org-name/repo-name/entities.yaml

# A configuration for the TechDocs plugin. This example instructs the plugin to
# build documentation at runtime, instead of pulling prebuilt HTML from S3
techdocs:
  builder: 'local'
  publisher:
    type: 'local'
  generator:
    runIn: local
```

Since you're using the {product_name_rhdh} Helm Chart to install and manage your internal developer portal, your configuration is nested under an `upstream.backstage.appConfig` property a Helm Values file. View your configuration by visiting your https://gitlab-gitlab.{openshift_cluster_ingress_domain}rhdh/developer-hub-config/-/blob/main/values.yaml[rhdh/developer-hub-config repository on GitLab].

Your workshop environment has been pre-configured such that this repository in GitLab is continuously monitored and deployed using a https://openshift-gitops-server-openshift-gitops.{openshift_cluster_ingress_domain}/applications[`backstage` Application in OpenShift GitOps] (login using the `admin` user and the password found in the https://console-openshift-console.{openshift_cluster_ingress_domain}/k8s/ns/openshift-gitops/secrets/openshift-gitops-cluster[openshift-gitops-cluster Secret]).

With that out of the way, let's get to work on configuring your instance of {product_name_rhdh}!

== Activity: Access Developer Hub

{product_name_rhdh} has been pre-deployed with a base configuration in your workshop environment. You can find and access it in the https://console-openshift-console.{openshift_cluster_ingress_domain}/topology/ns/backstage[backstage project on OpenShift].

Login to {product_name_rhdh}:

. Visit the https://console-openshift-console.{openshift_cluster_ingress_domain}/topology/ns/backstage?view=graph[backstage project] in your OpenShift cluster.
. Select the *backstage-developer-hub* Deployment in the Topology View.
. Click the URL listed under the *Resources* tab; it will be similar to https://backstage-backstage.{openshift_cluster_ingress_domain}/

The sign-in page will be displayed, with the option to login as a Guest. Click the *Enter* button to use the Guest sign-in.

NOTE: Ignore the GitHub sign-in method if it's displayed. It is not configured and will not work. 

WARNING: The Guest sign-in option is currently enabled, but you'll configure a production-ready sign-in option based on OpenID Connect shortly. The Guest sign-in option is only meant for development and testing purposes.

Visit the *Catalog* using the link in the menu on the left-hand side of the {product_name_rhdh} UI. You'll find that it's empty, and that the *Kind* dropdown doesn't provide any options - let's fix that!

== Activity: Synchronize User & Group Entities

You previously learned that the Software Catalog contains Entities, and saw a sample `appConfig` that contained a `catalog.locations` configuration. That example configuration imported entities from a file located in a Git repository. This pattern is known as a https://backstage.io/docs/features/software-catalog/#static-catalog-configuration[static configuration]. {product_name_rhdh} will ocassionally poll for updates to the specified file locations and update the Entities in the Software Catalog accordingly.

Another option for importing and synchronizoing Entities is via _providers_. Providers are typically provided by way of plugins, and are configured using the `catalog.providers` entry in the `appConfig`. Let's use the Keycloak plugin to synchronize Users and Groups to your Software Catalog.

. View your https://gitlab-gitlab.apps.cluster-6qqts.dynamic.redhatworkshops.io/rhdh/developer-hub-config/-/blob/main/values.yaml[values.yaml file in the developer-hub-config repository].
. Select **Edit > Edit single file**.
. Find the `janus-idp-backstage-plugin-keycloak-backend-dynamic` package under the `dynamic.plugins` field, and set `disabled: false`.
. Uncomment the `keycloakOrg` configuration within the `appConfig.catalog.providers` block.

This block of configuration instructs the Keycloak provider to synchronize Users and Groups from the specified Realm to the Software Catalog. Doing so will enable dvelopers and platform engineers to associate Users and Groups with Entities in the Software Catalog - very useful for finding out which individual or team is responsible for a particular microservice or database, for example.

. Scroll down and enter a commit message: `feat: enable the keycloak catalog provider`
. Click the *Commit* button.
. Visit the https://openshift-gitops-server-openshift-gitops.{openshift_cluster_ingress_domain}/applications[`backstage` Application in OpenShift GitOps] and click *Refresh*.

Your changes will start to rollout. Confirm this by visiting the https://console-openshift-console.{openshift_cluster_ingress_domain}/topology/ns/backstage?view=graph[backstage project] on OpenShift and checking the a new Pod is being started, or waiting until the Application in OpenShift GitOps reports *Healthy* instead of *Progressing*.

image::./m2/gitops-progressing.png[Backstage Application in Progressing Status]

Once the new Pod has started, check the logs for lines that reference the `KeycloakOrgEntityProvider`. You should see line stating that a number of Users and Groups have been read from Keycloak.

image::./m2/openshift-pod-logs.png[{product_name_rhdh} Pod logs as seen in the OpenShift Console]

You can further confirm the Users and Groups have been synchronized by visiting the Software Catalog and setting the *Kind* dropdown to User. 

image::./m2/rhdh-users-list.png[User Entities listed in {product_name_rhdh}]

Nice work! You enabled a dynamic plugin configured a catalog provider based on it!

== Activity: Configure OpenID Connect Authentication

{product_name_rhdh} supports four authentication providers:

* Guest (suitable for experimentation and demos only)
* OpenID Connect
* GitHub
* Microsoft Azure

In this activity you'll configure an OpenID Connect authentication provider - this will enable developers within your organizationto login using their single-sign on credentials. In this workshop environment, your users are sourced from GitLab and the Red Hat Build of Keycloak is used as the identity broker between {product_name_rhdh} and your GitLab instance.

TODO: DIAGRAM SHOWING AUTH FLOW

=== High-Level Workflow

A complete set of documentation for configuring OpenID Connect authentication using Red Hat Single-Sign On is available in the https://docs.redhat.com/en/documentation/red_hat_developer_hub/1.3/html-single/authentication/index#enabling-authentication-with-rhsso[{product_name_rhdh} documentation]. 

NOTE: Don't worry if some of the following bullet points are hard to understand upon first reading them. You'll be guided through each step-by-step.

The high-level steps involve:

. Configuring the Keycloak Backstage plugin to synchronize users from Red Hat Single-Sign On to {product_name_rhdh}.
. Creating a Realm in Red Hat Single-Sign On. This has been pre-configured for you. View the Realm using the following URL and credentials:
    * *URL*: https://sso.{openshift_cluster_ingress_domain}
    * *Credentials*: https://console-openshift-console.{openshift_cluster_ingress_domain}/k8s/ns/keycloak/secrets/keycloak-initial-admin[View on OpenShift]
. Configuring the `oidc` {product_name_rhdh} authentication provider with the Realm details.
. Setting `oidc` as `signInPage` page type for {product_name_rhdh}.
. Enabling session support on {product_name_rhdh}.

=== Configure the OpenID Connect Authentication Provider

. Visit your https://gitlab-gitlab.{openshift_cluster_ingress_domain}rhdh/developer-hub-config/[rhdh/developer-hub-config repository on GitLab].
. Open the *values.yaml* file, then select *Edit > Edit single file*.
. Locate the `appConfig.auth` object in the YAML.
. Delete the `auth.providers.guest` configuration.
. Uncomment the entire `auth` configuration.

This is an example standard Backstage `auth` configuration. Here's a summary of what this configuration specifies:

. Enable sessions, and use the `BACKEND_SECRET` environment variable to sign sessions.
. Set the authentication `environment` to `production`. Environments can have any arbitrary name.
. Enable the OpenID Connect provider (`providers.oidc`) with the following configuration:
    * Provide a `production` configuration (corresponding to the `environment` defined previously).
    * Use the `backstage' Realm (`metadataUrl`).
    * Load the `clientId` and `clientSecret` from environment variables (loaded from the precreated `oauth-client` Secret specified in `extraEnvVarsSecrets`)
    * Map any signing in user identity to a a User Entity in {product_name_rhdh} using the specified https://backstage.io/docs/auth/identity-resolver/[resolver].

Next, uncomment the `signInPage`. This property is specific to {product_name_rhdh}. It ensures the correct sign in UI is rendered. In upstream Backstage this requires React code changes.

Commit the changes with a message similar to `feat: enable openid connect`, and make sure Refresh the https://openshift-gitops-server-openshift-gitops.{openshift_cluster_ingress_domain}/applications[`backstage` Application in OpenShift GitOps].

=== Login using OpenID Connnect Authentication

Once the latest version of your `appConfig` has been synchronized and rolled out, visit your https://backstage-backstage.{openshift_cluster_ingress_domain}/[{product_name_rhdh} instance]. You will be prompted to sign-in using OpenID Connect.

image::./m2/rhdh-oidc-login.png[OIDC Sign-In Prompt]

Login using the username `pe1` and passowrd `TODO` in the popup that appears. After logging in, visit the *Settings* page in {product_name_rhdh} to confirm you're logged in as the `pe1` user.

image::./m2/rhdh-pe1-user.png[Viewing the user details on the Settings UI in {product_name_rhdh}]

== Activity: Enabling GitLab Entity Discovery

Now that the import of User and Group entities, and authentication is enabled for those same users, let's focus on importing existing Entities from Git.

Much like the Keycloak provider, you can use a https://backstage.io/docs/integrations/gitlab/discovery/[GitLab provider to discover] and import Entities from repositories in GitLab. This functionality is provided by the 	
https://npmjs.com/package/@backstage/plugin-catalog-backend-module-gitlab/v/0.3.21[@backstage/plugin-catalog-backend-module-gitlab plugin]. You can see that this is a supported https://docs.redhat.com/en/documentation/red_hat_developer_hub/1.3/html/dynamic_plugins_reference/con-preinstalled-dynamic-plugins#rhdh-community-plugins[dynamic plugin in the {product_name_rhdh} documentation].

To install and configure this plugin:

. Visit the https://gitlab-gitlab.{openshift_cluster_ingress_domain}rhdh/developer-hub-config/-/blob/main/values.yaml[rhdh/developer-hub-config repository] in your GitLab instance.
. Select *Edit *Edit single file*.
. Add the following block to the `dynamic.plugins` section of the YAML:
+
[source,yaml]
----
- package: ./dynamic-plugins/dist/backstage-plugin-catalog-backend-module-gitlab-dynamic
  disabled: false
----
. Find the `appConfig.catalog.providers` configuration and add the following entry.
+
[source,yaml]
----
gitlab:
  default:
    host: gitlab-gitlab.{openshift_cluster_ingress_domain}
    branch: main
    fallbackBranch: master
    skipForkedRepos: true
    entityFilename: catalog-info.yaml
    schedule:
    frequency: { minutes: 2 }
    timeout: { minutes: 3 }
    initialDelay: { seconds: 15 }
----
. Commit your changes with a message `feat: add gitlab autodiscovery`.
. Click the *Refresh* button on the https://openshift-gitops-server-openshift-gitops.{openshift_cluster_ingress_domain}/applications[`backstage` Application in OpenShift GitOps].

After a few moments your new {product_name_rhdh} configuration will finish rolling out. Check the logs for the new {product_name_rhdh} Pod. You should see that the `global-techdocs` repository was discovered.

image::./m2/rhdh-logs-gitlab-discovery.png[GitLab Autodiscovery Logs in the OpenShift Console]

== Conclusion

TODO
